# -*- coding: utf-8 -*-
"""Efficient/Advance python functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-GsJ4uMah-lgoIG2UsWbgC5ADWfGjyCT

<h1>args and *kwargs </h1>
The args and *kwargs syntax allows functions to accept various arguments. The args parameter collects positional arguments into a tuple, while *kwargs collects keyword arguments into a dictionary.
"""

def print_arguments(*args, **kwargs):
    for arg in args:
        print(arg)
    # for key, value in kwargs.items():
    #     print(f"{key}: {value}")
print_arguments('Hello', 'World', name='Alice', age=25)

def print_arguments(*args, **kwargs):
    # for arg in args:
    #     print(arg)
    for key, value in kwargs.items():
        print(f"{key}: {value}")
print_arguments('Hello', 'World', name='Alice', age=25)

"""<h1>collections.Counter for Counting Elements</h1>
The collections.Counter class provides a convenient way to count elements in an iterable. It returns a dictionary-like object where the elements are the keys, and the counts are the values.
"""

from collections import Counter
fruits = ['apple', 'banana', 'cherry', 'banana']
fruit_counts = Counter(fruits)
print(fruit_counts)  # Output: Counter({'banana': 2, 'apple': 1, 'cherry': 1})

"""<h1> any() and all() Functions </h1>
The any() and all() functions are useful for working with iterable data structures. The any() function returns True if at least one element in the iterable is True, while the all() function returns True only if all elements are True.
"""

numbers = [1, 2, 3, 4, 5]
print(any(num > 3 for num in numbers))  # Output: True
print(all(num > 3 for num in numbers))  # Output: False

"""<h1>collections.defaultdict for Default Values</h1>
The collections module provides a handy class called defaultdict, which is a subclass of the built-in dict class. It automatically assigns a default value to a key if it doesn’t exist, eliminating the need for explicit checks.
"""

from collections import defaultdict
fruit_counts = defaultdict(int)
fruits = ['apple', 'banana', 'cherry', 'banana']
for fruit in fruits:
    fruit_counts[fruit] += 1
print(fruit_counts)  # Output: {'apple': 1, 'banana': 2, 'cherry': 1}

"""<h1> zip() Function for Parallel Iteration</h1>
The zip() function allows you to iterate over multiple iterables in parallel. It takes multiple iterables as input and returns an iterator that produces tuples containing elements from each iterable.
"""

names = ['Alice', 'Bob', 'Charlie']
ages = [25, 32, 40]
for name, age in zip(names, ages):
    print(f"Name: {name}, Age: {age}")

"""<h1>enumerate() Function</h1>
When you need to iterate over an iterable and track each element’s index, the enumerate() function comes in handy. It returns an iterator of tuples containing the index and the corresponding element.
"""

fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits):
    print(f"Index: {index}, Fruit: {fruit}")

"""<h1> Leverage Generator Expressions for Memory Efficiency</h1>
Similar to list comprehensions, generator expressions allow you to create iterators in a concise manner. The key difference is that generator expressions don’t store the entire sequence in memory, making them more memory-efficient. Use parentheses instead of square brackets to create a generator expression:
"""

# List comprehension (creates a list)
squared_numbers = [num ** 2 for num in numbers]
# Generator expression (creates an iterator)
squared_numbers = (num ** 2 for num in numbers)

"""<h1> Decorate Functions with @staticmethod and @classmethod </h1>
The @staticmethod decorator allows you to define static methods within a class. These methods don’t have access to the instance or class itself but can be called without instantiating an object. Similarly, the @classmethod decorator defines methods that receive the class itself as the first argument instead of the instance.

"""

class MathUtils:
    @staticmethod
    def square(x):
        return x ** 2
    @classmethod
    def cube(cls, x):
        return x ** 3

print(MathUtils.square(3))  # Output: 9
print(MathUtils.cube(3))  # Output: 27

"""<h1> slots to Reduce Memory Usage </h1>
Python stores instance attributes in a dictionary by default, which can consume a significant amount of memory, especially when creating many instances. However, you can use the slots attribute to tell Python to allocate memory for a fixed set of instance variables, reducing memory usage.
"""

class Point:
    __slots__ = ['x', 'y']
    def __init__(self, x, y):
        self.x = x
        self.y = y

from contextlib import suppress
with suppress(FileNotFoundError):
    with open('file.txt', 'r') as file:
        contents = file.read()